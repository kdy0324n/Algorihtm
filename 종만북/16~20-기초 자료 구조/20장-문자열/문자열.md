### 문자열

------

#### 1. 도입

현대의 컴퓨터는 많은 양의 문자열 자료를 다룬다. 예로 문서파일, 웹페이지, 이메일, 문자메시지등이 있다. 문자열 알고리즘은 비교적 구현이 간단한 알고리즘이 사용된다. 검색문제를 위한 kmp알고리즘, 문자열 처리 스위스칼이라고 하는 접미사 배열등이 있다.

#### 2. 용어

|S| = S의 문자열의 길이

S[i] = 문자열의 i번재 원소 ex) abcdef에서 S[3] = d

S[i..j] = 문자열의 i번째 원소부터 j번재 원소까지의 문자열

S[...a] = S의 0번 글자부터 a번 글자까지로 구성된 부분 문자열 = 접두사

S[b...] = S의 b번 글자부터 끝까지의 글자까지로 구성된 부분 문자열 = 접미사

#### 3. kmp 알고리즘

kmp 알고리즘은 긴 글에서 찾으려고 하는 문자열이 있을때 빠르게 찾을수 있는 알고리즘이다. 긴글에서 문자열을 찾을려고 하면 제일 먼저 생각나는 방법이 일일이 하나씩 비교를 해본는 것인데 이를 사용하면 최악의 경우 긴글의 길이(n) * 찾으려는 문자열의 길이(m)이므로 매우 시간이 오래 걸린다. 이때 불일치가 일어났을때 지금까지 일치한 글자의 수를 이용해 다음으로 시도해야 할 시작 위치를 찾아내는 알고리즘이  kmp알고리즘이다.



기본 구현

```c++
vector<int>getpi(string str) {
    int n = str.size();
    vector<int>pi(n, 0);
    int j = 0;
    for (int i = 1; i < n; i++) {
        while (j > 0 && str[i] != str[j])j = pi[j - 1];
        if (str[i] == str[j])pi[i] = ++j;
    }
    return pi;
}

vector<int>kmp(string par, string str) {
    int n = par.size();
    int m = str.size();
    vector<int>ans;
    vector<int>pi = getpi(str);
    int j = 0;
    for (int i = 0; i < n; i++) {
        while (j > 0 && par[i] != str[j])j = pi[j - 1];
        if (par[i] == str[j]) {
            if (m - 1 == j) {
                ans.push_back(i - m + 1);
                j = pi[j];
            }
            else j++;
        }
    }
    return ans;
}
```

**문제: 재하의 금고(JAEHASAFE)**

이 문제는 금고가 돌아가져 있는 상태의 수 n이 주어지며 현재 상태에서 다음 상태로 얼마나 돌려야 만들수 있는가?를 구하는 문제이다. 이때 돌리는 수는 최소여야 하며 현재 상태에서 다음 상태 넘어갈때 오른쪽과 왼쪽으로 돌리는 경우가 매번 바뀐다. 처음에는 오른쪽으로 돌려진다. 풀이는 현재상태를 a, 다음 상태를 b라고 할때 오른쪽으로 돌리므로 a의 문자열을 살펴보는 방향은 왼쪽으로 진행될것이다. 따라서 a를 b+b에서 찾고 , 왼쪽으로 돌릴때는 b를 a+a에서 찾으면 된다.
